using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Wintellect.PowerCollections;

namespace ReindexAutomation.Client.Cloud
{    

    //TODO: LinkedHashMap
    //TODO: Serialize normal
    public class ZkNodeProps
    {
        private readonly IDictionary<string, object> propMap;

        /**
         * Construct ZKNodeProps from map.
         */
        public ZkNodeProps(IDictionary<string, object> propMap)
        {
            this.propMap = propMap;
            // TODO: store an unmodifiable map, but in a way that guarantees not to wrap more than once.
            // Always wrapping introduces a memory leak.
        }

        public ZkNodeProps plus(string key, object val)
        {
            return plus(new Dictionary<string, object> { { key, val } });
        }

        public ZkNodeProps plus(IDictionary<string, object> newVals)
        {
            var copy = new OrderedDictionary<string, object>(propMap);
            if (newVals == null || !newVals.Any())
            {
                return new ZkNodeProps(copy);
            }
            copy.AddMany(newVals);
            return new ZkNodeProps(copy);
        }


        /**
         * Constructor that populates the from array of Strings in form key1, value1,
         * key2, value2, ..., keyN, valueN
         */
        public ZkNodeProps(params string[] keyVals) : this(Utils.MakeMap(keyVals))
        {
            
        }

        public static ZkNodeProps fromKeyVals(params object[] keyVals)
        {
            return new ZkNodeProps(Utils.MakeMap(keyVals));
        }


        /**
         * Get property keys.
         */
        public ICollection<string> keySet()
        {
            return propMap.Keys;
        }

        /**
         * Get all properties as map.
         */
        public IDictionary<string, object> getProperties()
        {
            return propMap;
        }

        /** Returns a shallow writable copy of the properties */
        public IDictionary<string, object> shallowCopy()
        {
            return new OrderedDictionary<string, object>(propMap);            
        }

        /**
         * Create Replica from json string that is typically stored in zookeeper.
         */
        public static ZkNodeProps load(byte[] bytes)
        {
            var props = JsonConvert.DeserializeObject<IDictionary<string, object>>(Encoding.UTF8.GetString(bytes));
            return new ZkNodeProps(props);
        }

        /**
         * Get a string property value.
         */
        public string getStr(string key)
        {
            var o = propMap[key];
            return o?.ToString();
        }

        /**
         * Get a string property value.
         */
        public int getInt(string key, int def)
        {
            var o = propMap[key];
            return o == null ? def : int.Parse(o.ToString());
        }

        /**
         * Get a string property value.
         */
        public string getStr(string key, string def)
        {
            var o = propMap[key];
            return o?.ToString() ?? def;
        }

        public object get(string key)
        {
            return propMap[key];
        }

        public override string ToString()
        {
            return JsonConvert.SerializeObject(this);
            /***
            StringBuilder sb = new StringBuilder();
            Set<Entry<String,Object>> entries = propMap.entrySet();
            for(Entry<String,Object> entry : entries) {
              sb.append(entry.getKey() + "=" + entry.getValue() + "\n");
            }
            return sb.toString();
            ***/
        }

        /**
         * Check if property key exists.
         */
        public bool containsKey(string key)
        {
            return propMap.ContainsKey(key);
        }

        public bool getBool(string key, bool b)
        {
            var o = propMap[key];
            switch (o)
            {
                case null:
                    return b;
                case bool b1:
                    return b1;
            }
            return bool.Parse(o.ToString());
        }


        public override bool Equals(object that)
        {
            return that is ZkNodeProps props && props.propMap.Equals(propMap);
        }

        //Generated by ReSharper, need to be checked
        public override int GetHashCode()
        {
            return -893431362 + EqualityComparer<IDictionary<string, object>>.Default.GetHashCode(propMap);
        }
    }
}
